package directory

import (
	"encoding/json"
	"net/http"
	"net/url"
	"testing"
)

func assertErrorResponse(t *testing.T, r *record, res *http.Response, body ...byte) {
	t.Helper()
	if res == nil {
		fatal(t, r, "previous errors")
	}

	if len(body) == 0 {
		body = httpReadBody(res, t)
	}

	var problemDetails map[string]any
	err := json.Unmarshal(body, &problemDetails)
	if err != nil {
		t.Fatalf("Error decoding body: %s", err)
	}

	// check status
	t.Run("status", func(t *testing.T) {
		/*
			"status" (number) - The HTTP status code ([RFC7231], Section 6)
			generated by the origin server for this occurrence of the problem.

			The "status" member, if present, is only advisory; it conveys the
			HTTP status code used for the convenience of the consumer.
			Generators MUST use the same status code in the actual HTTP response,
			to assure that generic HTTP software that does not understand this
			format still behaves correctly.

			https://datatracker.ietf.org/doc/html/rfc7807#section-3.1
		*/
		if _, found := problemDetails["status"]; !found {
			fatal(t, r, "Missing status field in body: %s", body)
		}
		problemDetailsStatusFloat, ok := problemDetails["status"].(float64) // JSON number is float64
		if !ok {
			fatal(t, r, "status field not a number: %T: %v", problemDetails["status"], problemDetails["status"])
		}
		problemDetailsStatus := int(problemDetailsStatusFloat)
		if problemDetailsStatus != res.StatusCode {
			fatal(t, r, "status field not equal to http status code. Got: %d, expected: %d", problemDetailsStatus, res.StatusCode)
		}
	})

	problemType := "about:blank"
	t.Run("type", func(t *testing.T) {
		/*
			"type" (string) - A URI reference [RFC3986] that identifies the
			problem type.  This specification encourages that, when
			dereferenced, it provide human-readable documentation for the
			problem type (e.g., using HTML [W3C.REC-html5-20141028]).  When
			this member is not present, its value is assumed to be
			"about:blank".

			Consumers MUST use the "type" string as the primary identifier for
			the problem type; the "title" string is advisory and included only
			for users who are not aware of the semantics of the URI and do not
			have the ability to discover them (e.g., offline log analysis).
			Consumers SHOULD NOT automatically dereference the type URI.

			https://datatracker.ietf.org/doc/html/rfc7807#section-3.1
		*/
		if _, found := problemDetails["type"]; !found {
			skip(t, r, "Missing type field in body: %s", body)
		}
		problemDetailsType, ok := problemDetails["title"].(string)
		if !ok {
			fatal(t, r, "title field not string: %T: %v", problemDetails["title"], problemDetails["title"])
		}
		if problemDetailsType != "about:blank" {
			_, err = url.ParseRequestURI(problemDetailsType)
			if err != nil {
				fatal(t, r, "type field not a valid URI. Got: %s", problemDetailsType)
			}
		}
		problemType = problemDetailsType
	})

	// about:blank
	t.Run("title", func(t *testing.T) {
		/*
			"title" (string) - A short, human-readable summary of the problem
			type.  It SHOULD NOT change from occurrence to occurrence of the
			problem, except for purposes of localization (e.g., using
			proactive content negotiation; see [RFC7231], Section 3.4).

			When "about:blank" is used, the title SHOULD be the same as the
			recommended HTTP status phrase for that code (e.g., "Not Found" for
			404, and so on), although it MAY be localized to suit client
			preferences (expressed with the Accept-Language request header).

			https://datatracker.ietf.org/doc/html/rfc7807#section-4.2
		*/
		if problemType == "about:blank" {
			skip(t, r, "type field set to about:blank. Skip title test.")
		}
		if _, found := problemDetails["title"]; !found {
			fatal(t, r, "Missing title field in body: %s", body)
		}
		problemDetailsTitle, ok := problemDetails["title"].(string)
		if !ok {
			fatal(t, r, "title field not string: %T: %v", problemDetails["title"], problemDetails["title"])
		}
		if problemDetailsTitle != http.StatusText(res.StatusCode) {
			fatal(t, r, "title field not equal to http status text. Got: %s, expected: %s", problemDetailsTitle, http.StatusText(res.StatusCode))
		}
	})
}
