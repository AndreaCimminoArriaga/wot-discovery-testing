package directory

import (
	"encoding/json"
	"net/http"
	"net/url"
	"testing"
)

// RFC7807 Problem Details (https://tools.ietf.org/html/rfc7807)
type ProblemDetails struct {
	Type     string `json:"type"`
	Title    string `json:"title"`
	Status   int    `json:"status"`
	Detail   string `json:"detail"`
	Instance string `json:"instance"`
	// Discovery extension for validation errors
	ValidationErrors []ValidationError `json:"validationErrors"`
}

type ValidationError struct {
	Field       string `json:"field"`
	Description string `json:"description"`
}

func assertErrorResponse(t *testing.T, r *record, res *http.Response, body []byte, validation bool) {
	t.Helper()
	if res == nil {
		fatal(t, r, "previous errors")
	}

	if len(body) == 0 {
		body = httpReadBody(res, t)
	}

	var problemDetails ProblemDetails
	err := json.Unmarshal(body, &problemDetails)
	if err != nil {
		t.Fatalf("Error decoding body: %s", err)
	}

	// check status
	t.Run("status", func(t *testing.T) {
		/*
			"status" (number) - The HTTP status code ([RFC7231], Section 6)
			generated by the origin server for this occurrence of the problem.

			The "status" member, if present, is only advisory; it conveys the
			HTTP status code used for the convenience of the consumer.
			Generators MUST use the same status code in the actual HTTP response,
			to assure that generic HTTP software that does not understand this
			format still behaves correctly.

			https://datatracker.ietf.org/doc/html/rfc7807#section-3.1
		*/
		if problemDetails.Status != res.StatusCode {
			fatal(t, r, "status field not equal to http status code. Got: %d, expected: %d", problemDetails.Status, res.StatusCode)
		}
	})

	t.Run("type", func(t *testing.T) {
		/*
			"type" (string) - A URI reference [RFC3986] that identifies the
			problem type.  This specification encourages that, when
			dereferenced, it provide human-readable documentation for the
			problem type (e.g., using HTML [W3C.REC-html5-20141028]).  When
			this member is not present, its value is assumed to be
			"about:blank".

			Consumers MUST use the "type" string as the primary identifier for
			the problem type; the "title" string is advisory and included only
			for users who are not aware of the semantics of the URI and do not
			have the ability to discover them (e.g., offline log analysis).
			Consumers SHOULD NOT automatically dereference the type URI.

			https://datatracker.ietf.org/doc/html/rfc7807#section-3.1
		*/
		if problemDetails.Type == "" {
			problemDetails.Type = "about:blank"
			skip(t, r, "Missing type. Defaults to about:blank")
		}
		if problemDetails.Type != "about:blank" {
			_, err = url.ParseRequestURI(problemDetails.Type)
			if err != nil {
				fatal(t, r, "type field not a valid URI. Got: %s", problemDetails.Type)
			}
		}
	})

	// about:blank
	t.Run("title", func(t *testing.T) {
		/*
			"title" (string) - A short, human-readable summary of the problem
			type.  It SHOULD NOT change from occurrence to occurrence of the
			problem, except for purposes of localization (e.g., using
			proactive content negotiation; see [RFC7231], Section 3.4).

			When "about:blank" is used, the title SHOULD be the same as the
			recommended HTTP status phrase for that code (e.g., "Not Found" for
			404, and so on), although it MAY be localized to suit client
			preferences (expressed with the Accept-Language request header).

			https://datatracker.ietf.org/doc/html/rfc7807#section-4.2
		*/
		if problemDetails.Type == "about:blank" {
			skip(t, r, "type field set to about:blank. Skip title test.")
		}

		if problemDetails.Title != http.StatusText(res.StatusCode) {
			fatal(t, r, "title field not equal to http status text. Got: %s, expected: %s", problemDetails.Title, http.StatusText(res.StatusCode))
		}
	})

	if validation {
		assertValidationResponse(t, r, problemDetails.ValidationErrors)
	}
}

func assertValidationResponse(t *testing.T, r *record, validationErrors []ValidationError) {
	t.Helper()
	t.Run("validation errors", func(t *testing.T) {
		if len(validationErrors) < 1 {
			t.Fatalf("expected one or more validation errors, got: %d.", len(validationErrors))
		}
		for _, validationError := range validationErrors {

			if validationError.Field == "" {
				t.Fatalf("Missing validation error field in: %s", marshalPrettyJSON(validationError))
			}

			if validationError.Description == "" {
				t.Fatalf("Missing validation error description in: %s", marshalPrettyJSON(validationError))
			}
		}
	})

}
