package directory

import (
	"encoding/json"
	"net/http"
	"net/url"
	"testing"
)

// RFC7807 Problem Details (https://tools.ietf.org/html/rfc7807)
type ProblemDetails struct {
	Type     string `json:"type"`
	Title    string `json:"title"`
	Status   int    `json:"status"`
	Detail   string `json:"detail"`
	Instance string `json:"instance"`
	// Discovery extension for validation errors
	ValidationErrors []ValidationError `json:"validationErrors"`
}

type ValidationError struct {
	Field       string `json:"field"`
	Description string `json:"description"`
}

func assertErrorResponse(t *testing.T, r *record, res *http.Response, body []byte) {
	t.Helper()
	if res == nil {
		fatal(t, r, "previous errors")
	}

	if len(body) == 0 {
		panic("empty body")
	}

	var problemDetails ProblemDetails
	err := json.Unmarshal(body, &problemDetails)
	if err != nil {
		t.Fatalf("Error decoding body: %s", err)
	}

	/*
		"status" (number) - The HTTP status code ([RFC7231], Section 6)
		generated by the origin server for this occurrence of the problem.

		The "status" member, if present, is only advisory; it conveys the
		HTTP status code used for the convenience of the consumer.
		Generators MUST use the same status code in the actual HTTP response,
		to assure that generic HTTP software that does not understand this
		format still behaves correctly.

		https://datatracker.ietf.org/doc/html/rfc7807#section-3.1
	*/
	if problemDetails.Status != res.StatusCode {
		fatal(t, r, "status field not equal to http status code. Got: %d, expected: %d", problemDetails.Status, res.StatusCode)
	}

	/*
		"type" (string) - A URI reference [RFC3986] that identifies the
		problem type.  This specification encourages that, when
		dereferenced, it provide human-readable documentation for the
		problem type (e.g., using HTML [W3C.REC-html5-20141028]).  When
		this member is not present, its value is assumed to be
		"about:blank".

		Consumers MUST use the "type" string as the primary identifier for
		the problem type; the "title" string is advisory and included only
		for users who are not aware of the semantics of the URI and do not
		have the ability to discover them (e.g., offline log analysis).
		Consumers SHOULD NOT automatically dereference the type URI.

		https://datatracker.ietf.org/doc/html/rfc7807#section-3.1
	*/
	if problemDetails.Type == "" {
		problemDetails.Type = "about:blank"
	} else if problemDetails.Type != "about:blank" {
		_, err = url.ParseRequestURI(problemDetails.Type)
		if err != nil {
			fatal(t, r, "type field not a valid URI. Got: %s", problemDetails.Type)
		}
	}

	/*
		"title" (string) - A short, human-readable summary of the problem
		type.  It SHOULD NOT change from occurrence to occurrence of the
		problem, except for purposes of localization (e.g., using
		proactive content negotiation; see [RFC7231], Section 3.4).

		When "about:blank" is used, the title SHOULD be the same as the
		recommended HTTP status phrase for that code (e.g., "Not Found" for
		404, and so on), although it MAY be localized to suit client
		preferences (expressed with the Accept-Language request header).

		https://datatracker.ietf.org/doc/html/rfc7807#section-4.2
	*/
	if problemDetails.Type != "about:blank" &&
		problemDetails.Title != http.StatusText(res.StatusCode) {
		fatal(t, r, "title field not equal to http status text. Got: %s, expected: %s", problemDetails.Title, http.StatusText(res.StatusCode))

	}
}

func assertValidationResponse(t *testing.T, r *record, res *http.Response, body []byte) {
	t.Helper()

	t.Helper()
	if res == nil {
		fatal(t, r, "previous errors")
	}

	if len(body) == 0 {
		body = httpReadBody(res, t)
	}

	var problemDetails ProblemDetails
	err := json.Unmarshal(body, &problemDetails)
	if err != nil {
		t.Fatalf("Error decoding body: %s", err)
	}

	validationErrors := problemDetails.ValidationErrors

	if len(validationErrors) < 1 {
		fatal(t, r, "expected one or more validation errors, got: %d.", len(validationErrors))
	}
	for _, validationError := range validationErrors {

		if validationError.Field == "" {
			fatal(t, r, "Missing validation error field in: %s", marshalPrettyJSON(validationError))
		}

		if validationError.Description == "" {
			fatal(t, r, "Missing validation error description in: %s", marshalPrettyJSON(validationError))
		}
	}
}
